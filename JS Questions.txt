Q1. Methods  that is not available in node
Ans - alert(),prompt(),confirm().
Q2. What is <Script> tag?
Ans :- it is used to insert JS Program in HTML('type' attr was mandatory in HTML4)
Q3. Diff between HTML4 vs HTML5?

Q4. How does javascript stores data in variable?
Ans:- Variable points to data in memory, then if value changes, variable will point to next location and older one will be removed  
Q5.diff b/w primitive vs non-primitive
Ans :- primitive datatype variable can store only one type of data.
Q6. special number type
Ans :- Infinity, -Infinity and NaN
Q7. What does null and undefined means?
Ans :- null refers to nothing , empty whereas undefined means “value is not assigned”.
Q8. What are Symbol in JS?
Ans Symbols are used to create unique identifiers.
Q9. Falsy values in JS?
Ans :- 0, null, undefined, NaN, "". Other than this every thing is truthy.
Q10. Some implicit coercion?
alert(2 + 2 + '1' ); // "41" and not "221"
alert('1' + 2 + 2); // "122" and not "14"
alert( 6 - '2' ); // 4, converts '2' to a number
alert( '6' / '2' ); // 3, converts both operands to numbers
Q.11 Assignment Chaining?
Ans :- using assignment in chaining form, a=b=c=2+2;
Q.12 Comma operator?
Ans :- when it is use only assign the last one.
let a = (1 + 2, 3 + 4);

alert( a ); // 7 (the result of 3 + 4)
Q.13 some implicit coercion?
"" + 1 + 0=10
"" - 1 + 0=1
true + false=1
6 / "3"=2
"2" * "3"=6
4 + 5 + "px"=9px
"$" + 4 + 5=$45
"4" - 2=2
"4px" - 2=NaN
"  -9  " + 5="  -9  5"
"  -9  " - 5=-14
null + 1=1 //null becomes 0
undefined + 1 = NaN
" \t \n" - 2 = -2 // special character are trimmed off during coercion

Q.14 string comparison?
Ans :- “dictionary” or “lexicographical” order.
Q.15 strange type conversion?
Ans :- Comparisons(>,<,>=,<=) convert null to a number, treating it as 0 whereas undefined gets converted to NaN by comparison operators.
alert( null > 0 );  // (1) false
alert( null == 0 ); // (2) false
alert( null >= 0 ); // (3) true
Q16. Multiple Ternary?
Ans :- checks for first expression, if true will return string value, if not goes to next expression and so on. 
let age = prompt('age?', 18);

let message = (age < 3) ? 'Hi, baby!' :
  (age < 18) ? 'Hello!' :
  (age < 100) ? 'Greetings!' :
  'What an unusual age!';

alert( message );
Q17. what is nullish coalescing operator?
Ans:- The nullish coalescing operator is written as two question marks ??.It returns the value that is defined and treats null and undefined same. || is diffrent from ?? because || return truthy vs ?? return defined. JavaScript forbids using ?? together with && and || operators, unless the precedence is explicitly specified with parentheses.
//result = (a !== null && a !== undefined) ? a : b; is same as result = a??b;
Q18. What is useMemo? why 
Ans :- useMemo is a hook that is used to memoize the values in react. So that component to render everytime but the expensive operation can be ignored.
Q19. does ternary operator allows break or continue?
Ans:- NO.  
Q.20 Why on Every Render component of render object, array and functions passed component also renders?
Ans:- it happens object array function in javascript are compared by reference and on every render the reference changes.
Q.21 What is switch?
Ans :-A switch statmemnt can replace multiple if statement and it is more descriptive way. 
Grouping of “case”
let a = 3;

switch (a) {
  case 4:
    alert('Right!');
    break;

  case 3: // (*) grouped two cases
  case 5:
    alert('Wrong!');
    alert("Why don't you take a math class?");
    break;

  default:
    alert('The result is strange. Really.');
//This will work for both cases 3 and 5
Q22. why to use HOF?
Ans :- code reusability and code modularity.
Q23.what happens if newlines are added between return and returning value?
Ans:- code will return undefined.
Q.24 Diff b/w function declaration and function expression?
Ans:- FD :  a function, declared as a separate statement, in the main code flow.
FE :  a function, created inside an expression or inside another syntax construct.
FD : 1. A Function Expression is created when the execution reaches it and is usable only from that moment.
FE : 1. A Function Declaration can be called earlier than it is defined.
In strict mode, when a Function Declaration is within a code block, it’s visible everywhere inside that block. But not outside of it.
Q.25 Why we use semicolon in function expression?
Ans :- because it is an expression and in expression, ; ends the line.
Q.26 Why Arrow functions were created?
Ans :- it was created so that the function cannot leave the current context.it does not have its own "this" and it takes it from outside. 
Q.27 What is transpiler?
Ans :- A transpiler is a special piece of software that translates source code to another source code. It can parse (“read and understand”) modern code and rewrite it using older syntax constructs.
Q.28 What is polyfills?
Ans :- A script that updates/adds new functions is called “polyfill”.

Q.29 what is an object?
Ans :- an object is a data type which can contain more complex data as properties.
We can use square brackets in an object literal, when creating an object. That’s called computed properties.
//1
let fruit = prompt("Which fruit to buy?", "apple");
let bag = {};

// take property name from the fruit variable
bag[fruit] = 5;
//2
let fruit = 'apple';
let bag = {
  [fruit + 'Computers']: 5 // bag.appleComputers = 5
};
"in" operator for key validation
example: obj={"age":18} console.log("age" in obj) // true
for..in operator for looping over object. for(let key in obj)
Q.30 are objects ordered?
ans : number keys are ordered but others keys are sorted as creation wise.
Q31. how object are stored and accessed?
Ans :- objects are stored in memory somewhere and variable stores the memory of it and the JavaScript engine looks at what’s at that address and performs the operation on the actual object.

Q32. how to make a shallow copy of object?
Ans : 1. Object.assign(dest, ...sources) or using for..in
Q33. for deep copy?(except)
Ans: structuredClone(obj); is a method that can do deep cloning
let user = {
  name: "John",
  sizes: {
    height: 182,
    width: 50
  }
};

let clone = structuredClone(user);
Q34. what is roots in memory management?
Ans : i.The currently executing function, its local variables and parameters.
ii. Other functions on the current chain of nested calls, their local variables and parameters.
iii. Global variables.
Any base set of inherently reachable values are roots
Q.35 what is this keyword?
Ans : "this" keyword is the special keyword in JS that has the access of object's information from which a method is being called. or we can also say that The value of this is the object “before dot”, the one used to call the method.

@@facts about this:
@ The value of this is evaluated during the run-time, depending on the context.
@@@ When a function is declared, it may use this, but that this has no value until the function is called.
@@@A function can be copied between objects.
@@@ When a function is called in the “method” syntax: object.method(), the value of this during the call is object.
@ Arrow func don’t have its “own” this. If we reference this from such a function, it’s taken from the outer “normal” function.

Q.36. What is constructor function?
Ans : Constructor function are like regular functions that is use to create similar kind of object(function name starts with Capital Letter and it is called with "new" keyword).
 When a function is executed with new, it does the following steps:
@A new empty object is created and assigned to this.
@The function body executes. Usually it modifies this, adds new properties to it.
@The value of this is returned.
// how an object forms.
function User(name) {
  // this = {};  (implicitly)

  // add properties to this
  this.name = name;
  this.isAdmin = false;

  // return this;  (implicitly)
}
@Testing constructor mode: to check use new.target.
function User() {
  alert(new.target);
}

// without "new":
User(); // undefined

// with "new":
new User(); // function User { ... }
Q37. what if we define a return in constructor?
Ans : 1. if it is an object then it will return that object but if any primitive value then it will ignore and return the object it supposed to.
Q.38 what if we use only semicolon (;) after new and name of the function in constructor function.
Ans : Nothing it will be treated as same but it is not a good practice.
let user = new User; // <-- no parentheses
// same as
let user = new User();
Q39. Can you tell me about some other variants of optional chaining?
Ans : 1. ?.() is used to call a function that may not exist.
2. ?.[] syntax also works, if we’d like to use brackets [] to access properties
3. (delete user?.name;) // delete user.name if user exists.  We can use ?. for safe reading and deleting, but not writing
Ex : 1. userGuest.admin?.(); // nothing happens (no such method)
2. alert( user2?.[key] ); // undefined

Q.40 what are Symbols in JS?
Ans : Symbol is a primitive type for unique identifiers.Symbols are created with Symbol() call with an optional description (name).
Q.41 What are global symbol?
Ans : by global symbol registry, We can create symbols in it and access them later, and it guarantees that repeated accesses by the same name return exactly the same symbol.
// read from the global registry
let id = Symbol.for("id"); // if the symbol did not exist, it is created

// read it again (maybe from another part of the code)
let idAgain = Symbol.for("id");

// the same symbol
alert( id === idAgain ); // true
AND : return a name by global symbol – we can use: Symbol.keyFor(sym).
// get symbol by name
let sym = Symbol.for("name");
let sym2 = Symbol.for("id");

// get name by symbol
alert( Symbol.keyFor(sym) ); // name
alert( Symbol.keyFor(sym2) ); // id
@@Symbols have two main use cases:

“Hidden” object properties.

If we want to add a property into an object that “belongs” to another script or a library, we can create a symbol and use it as a property key. A symbolic property does not appear in for..in, so it won’t be accidentally processed together with other properties. Also it won’t be accessed directly, because another script does not have our symbol. So the property will be protected from accidental use or overwrite.

So we can “covertly” hide something into objects that we need, but others should not see, using symbolic properties.

There are many system symbols used by JavaScript which are accessible as Symbol.*. We can use them to alter some built-in behaviors. For instance, later in the tutorial we’ll use Symbol.iterator for iterables, Symbol.toPrimitive to setup object-to-primitive conversion and so on.


